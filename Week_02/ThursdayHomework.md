## GC总结

### GCLogAnalysis演示
*实验运行环境：Mac 4C8GB OpenJDK11*
#### SerialGC
分别使用内存256m、512M、1G、2G、4G做实验（实验都只进行一次，可能偶尔因素比较大，而已写个自动化测试程序多次实验取平均）
256m出现OOM，其他的数值统计如下：

||512m|1G|2G|4G|
|---|---|---|---|---|
|生成对象|12371|14283|13034|10292|
|GC次数|28|11|5|2|
|YoungGC次数|18|10|5|2|
|FullGC次数|10|1|0|0|
|平均GC暂停时间|34.2|54|96|180|
GC次数随着堆的增加而减少，但是生成的对象却逐渐减少。推测是由于系统的内存较小，实际上的空闲内存不多，分配的堆内存如果超过空闲物理内存将会分配到虚拟内存，导致程序运行效率下降。GC暂停时间随着堆内存的增加而增加，由于堆内存越大，进行GC时的时间越大。

#### ParallelGC
由于256m仍然OOM，以后的实验都不采用256m，直接从512m开始，实验方法同串行GC，统计结果如下：
||512m|1G|2G|4G|
|---|---|---|---|---|
|生成对象|10550|17210|16754|14579|
|GC次数|36|26|8|3|
|FullGC次数|13|2|0|0|
|平均GC暂停时间|20.3|19.6|53.8|103|
相对于串行GC，平均GC暂停时间更短了，所以有更多的时间进行业务处理（生成对象），所以生成的对象数量比串行GC要多。但并行GC进行GC的次数要比串行要多些。

#### ConcMarkSweepGC
实验方法同上，统计结果如下：
||512m|1G|2G|4G|
|---|---|---|---|---|
|生成对象|14291|18886|15119|13935|
|GC次数|32|18|12|11|
|FullGC次数|10|0|0|0|
|平均GC暂停时间|17.5|22.3|41.5|51.8|
CMSGC的平均暂停时间和FullGC的次数都要少，生成对象略多于并行GC。另外OpenJDK报了以下警告：Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release。可能以后不支持CMS？

#### G1
实验方法同上，JDK11默认的GC是G1GC
||512m|1G|2G|4G|
|---|---|---|---|---|
|生成对象|15722|21589|17382|16560|
|GC次数|178|44|17|15|
|平均GC暂停时间|5.31|7.84|22.8|32|
G1的堆内存结构跟上面不一样，划分很多小区块，因为这样，GC次数相比上面的都明显增多，但是GC的平均暂停时间是明显减少，生成的对象数量都上面的要多。明显GC效率更好，现在作为默认的GC。





