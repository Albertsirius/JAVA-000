# Java进阶训练营学习总结

## JVM

### JVM基础知识

Java是一种面向对象、静态类型、编译执行、有VM/GC运行时的跨平台高级语言

### 字节码技术

1. 字节码的定义
2. 查看字节码

```shell
javap -c 
```

3. 字节码运行时结构

### JVM类加载器

1. 类的生命周期
2. 类的加载时机

- 正常加载的时机
- 可能会加载的时机

3. 加载器的类型

- 启动类加载器（BootstrapClassLoader）
- 扩展类加载器（ExtClassLoader）
- 应用类加载器（AppClassLoader）

4. 加载器的特点

### JVM内存模型

1. 整体结构
2. 栈内存结构
3. 堆内存结构

### JVM启动参数

1. 系统属性参数
2. 运行模式参数
3. 堆内存设置参数
4. GC设置参数
5. 分析诊断参数
6. JavaAgent参数

### JVM命令

1. 命名行命令
2. 图形化工具

### GC

1. GC一般原理

- 标记清除法
- 并行GC和CMS

2. 串行GC/并行GC
3. CMS GC/G1GC

### 总结

JVM知识这一章主要讲解Java底层的核心概念：字节码、类加载原理、内存模型和GC（垃圾回收）。总点是在理解类加载的顺序、内存的结构和各种GC的原理和优劣对比。要学会jvm启动的常用几个参数，使用jvm的命令行工具来检查线上的生产问题，以及通过不同的GC策略来调优

## NIO

### IO通信模型

1. 阻塞式IO
2. 非阻塞式IO
3. IO多路复用

- select/poll: 每次调用select，都需要从fd集合从用户态拷贝到内核态，开销大；支持的fd数量少
- Epoll

4. 信号驱动IO
5. 异步IO

- windows的IOCP模型

### Netty

1. Netty概述
2. 基本概念

- Channel：通道，Java NIO 中的基础概念,代表一个打开的连接,可执行读取/写入 IO 操作。Netty 对 Channel 的所有 IO 操作都是非阻塞的。
- ChannelFuture：Java 的 Future 接口，只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。Netty 封装一个 ChannelFuture 接口。
- Event & Handler：Netty 基于事件驱动，事件和处理器可以关联到入站和出站数据流。
- Encoder & Decoder：处理网络 IO 时，需要进行序列化和反序列化, 转换 Java 对象与字节流。对入站数据进行解码, 基类是 ByteToMessageDecoder。对出站数据进行编码, 基类是 MessageToByteEncoder。
- ChannelPipeline：数据处理管道就是事件处理器链。

### 高性能

1. 概念

- 高并发用户
- 高吞吐量
- 低延迟

2. Netty实现高性能

- 事件处理机制到Reactor模型：Reactor首先是事件驱动的，有一个或多个并发输入，有一个ServiceHandler和多个EventHandlers
- Rector模型到Netty NIO
- 关键对象

3. 网络程序优化

- 粘包与拆包
- Nagle与TCP_NODELAY
- 连接优化

### 总结

NIO知识这一章从介绍几种IO通信模型出发，介绍原理，优缺点，使用场景；然后介绍Netty框架，重点理解Netty的概念，并能够利用Netty框架进行网络编程，实现简单的API网关；最后通过Netty的通信模型原理，探讨网络优化的问题。

## 并发编程

### 多线程基础

1. 多线程使用原因
2. Java线程创建过程
3. 线程状态
   - start
   - Runnable
   - Running
   - Non-Runnable
   - Terminated

### Java多线程

1. Thread类使用
2. Thread类状态改变操作

- sleep
- yield
- join
- wait
- notify

3. 中断和异常处理
4. Thread状态

### 线程安全

1. 竞态条件：多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。s。不进行恰当的控制，会导致线程安全问题。
2. 并发相关性质

- 原子性
- 可见性
- 有序性
  - happens-before

3. synchronized

- 实现

4. volatile

- 实现

5. final

### 线程池及应用

1. 线程池：Excutor和ExcutorService
2. 线程池参数
3. 创建线程池方法

### Java并发包

1. 锁机制类

- 显示锁Lock
  - 使用优点
  - 接口
  - Condition
  - LockSupport
- 最佳实践

2. 原子操作类

- 无锁底层技术原理 - CAS指令

3. 线程池相关类：见线程池

4. 信号量工具类

- AQS
- Semaphore
- CoundownLatch
- CyclicBarrier
- Future/FutureTask/CompletableFuture

5. 并发集合类

- List线程安全
- CopyOnWriteArrayList
- HashMap线程安全
- ConcurrentHashMap
  - 分段式锁

### 并发编程相关

1. ThreadLocal：可以看做是 Context 模式，减少显式传递参数
2. 并行Stream：多线程执行，只需要加个 parallel 即可
3. 伪并发问题：通过业务规则可以控制并发问题

- 客户端控制（调用方），点击后按钮不可用，跳转到其他页
- 服务器端控制（处理端），给每个表单生成一个编号，提交时判断重复

4. 分布式下的锁和计数器

### 并发编程经验

1. 加锁考虑的问题
2. 线程间协作

### 总结

并发编程这一章首先介绍多线程开发技术使用的原因，线程是生命周期。重点要理解使用多线程会导致的问题，以及如何解决。学会Java多线程编程的相关概率：内存模型，锁机制，CAS指令。学会使用Thread创建线程、锁的使用、线程池如何创建和参数，并发工具、信号量工具、ThreadLocal等。最后讲解了并发编程时要注意的问题。

## Spring和ORM框架

### Spring框架设计

1. Spring的框架
2. Spring模块

### Spring AOP

1. 概念

- AOP-面向切面编程
- IoC-控制反转

2. 字节码增强工具

- 字节码增强与反射的区别
- CGLIB、ASM、AspectJ、Javassit、instrumentation
- ByteBuddy

### Spring Bean

1. Bean生命周期
2. Bean加载过程

*Spring管理对象生命周期以后，也就改变了编程和协作模式*

### Spring XML配置原理

1. 配置原理
2. 配置方法的演变

### SpringBoot核心原理

1. 从Spring到Springboot

- springboot做的简化

2. 自动化配置

- 约定大于配置
- 自动化配置原理
- 相关注解

2. starter

### JDBC与数据连接池

1. JDBC概念
2. 数据库连接池

### ORM框架

1. Hibernate
2. Mybatis

### Spring集成JPA和ORM

1. JPA概念：JPA 的全称是 Java Persistence API， 即 Java 持久化 API，是一套基于 ORM 的规范，内部是由一系列的接口和抽象类构成。
2. Spring管理事务

- 声明式事务管理
- 事务传播性
- 事务隔离型

3. Springboot集成JPA和ORM

### 总结

Spring框架这章教授了当前Java世界最热门以及最成熟的框架-Spring。通过讲解Spring的基本模块到核心概念，学会用Spring实现AOP编程。SpringBoot是基于Spring的一个大的提升产品，通过自动化配置，约定大于配置的方式简化了Spring程序的开发时间，学会使用spring已经写一个spring-starter。第三部分学习的是ORM框架，包括JDBC概念，使用已经流行的两大ORM框架Hibernate和Mybatis，学会把这两大框架如何集成到Spring和Springboot里面。

## 数据库

### 关系数据库

1. 数据库范式定义
2. 常见的关系数据库

### SQL语言

1. SQL语言包括：

- 数据查询语言DQL
- 数据操作语言DML
- 事务控制语言TCL
- 数据控制语言DCL
- 数据定义语言DDL
- 指针控制语言CCL

### MySQL数据库

1. MySQL的架构
2. MySQL执行流程
3. MySQL执行引擎和状态
4. MySQL对SQL的执行顺序
5. MySQL索引原理

- InnoDB是B+树实现聚集索引，单表数据最好不超过2000万

6. MySQL配置优化
7. MySQL数据库设计最佳实践

8. MySQL事务和锁

- 表级锁
  - 意向锁：表明事务稍后要进行那种类型的锁定(**上锁前需要先上意向锁!**)
    - 共享意向锁(IS)：打算在某些行上设置共享锁
    - 排他意向锁(IX): 打算对某些行设置排他锁
    - Insert 意向锁: Insert 操作设置的间隙锁
  - 自增锁(AUTO-IN)

- 行级锁(InnoDB)
  - 记录锁(Record): 始终锁定索引记录，注意隐藏的聚簇索引;
  - 间隙锁(Gap)
  - 临键锁(Next-Key): 记录锁+间隙锁的组合; 可“锁定”表中不存在记录
  - 谓词锁(Predicat): 空间索引

- 死锁
  - 阻塞与互相等待
  - 增删改、锁定读
  - 死锁检测与自动回滚
  - 锁粒度与程序设计

- 事务类型
  - 读未提交
  - 读已提交
  - 可重复读
  - 可串行化
- MySQL事务控制
  - Undo Log
  - Redo Log

### DB与SQL优化

1. 写入优化

- 大批量写入优化
- PrepareStatement减少SQL解析
- Multiple Values/Add Batch减少交互
- Load Data，直接导入
- 索引和约束问题(?)

2. 数据更新

- 数据更新范围
- 注意GAP Lock问题，锁范围扩大

3. 模糊查询

4. 连接查询

- 连接查询优化
- 驱动表的选择
- 避免笛卡尔积

5. 索引失效

6. 查询SQL优化

- 避免不必须的大量重复数据传输
- 避免临时文件排序或临时表
- 分析类需求，可以用汇总表

### 常见使用场景

1. 实现主键ID

- 自增
- Sequence
- 模糊seq
- UUID
- 时间戳/随机数
- snowflake

2. 高效分页

3. 乐观锁和悲观锁

### 总结

本章学习了数据库的相关知识，包括关系数据库的设计、SQL、MySQL数据库和数据库设计以及SQL优化等。在日常已经学会SQL的使用的基础上，要深入理解以下知识：如何设计数据库（范式、主键ID、索引设计）、SQL优化（事务概念、锁概念、SQL的最佳实践)、MySQL运行原理等。

## 分库分表

### 单机到集群

1. 单机面临的问题
2. 单机mysql的技术演进

### MySQL主从复制

1. 主从复制原理

- 核心：主库写binlog，从库relay log
- 半同步复制
- 组复制

2. 主从复制的局限性

- 主从延迟
- 应用侧需要配和读写分离框架
- 不解决高可用问题

### MySQL读写分离

1. 配置多个数据源，实现读写分离
2. 实现

- 1.0版本springboot实现
- 2.0版本数据库框架shardingsphere-jdbc
- 3.0版本数据库中间件shardingsphere-proxy

### MySQL高可用

1. 为什么使用高可用

- 读写分离，提升读的处理能力
- 故障转移，提供failover能力
- 加上业务侧连接池的心跳重试，实现断线重连，业务不间断，降低RTO和RPO

2. 高可用定义
3. 高可用策略

- 主从手动切换
- LVS+Keepalive
- MHA
- MGR
- MySQL Cluster
- Orchestrator

### 数据库拆分

1. 为什么要拆分

2. 数据库垂直拆分

- 拆库：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库
- 拆表：如果单表数据量过大，还可能需要对单表进行拆分
- 优缺点

3. 数据库水平拆分

- 分库
- 分表
- 分库分表
- 优缺点

### 框架和中间件

1. 演进

类库/框架（TDDL、Sharding-JDBC）->数据库中间件(DRDS、Sharding-Proxy、MyCAT...)->分布式数据库（Aurora、GaussDB、PolarDB、TiDB）->数据网格

2. Shardingsphere

### 数据移植

1. 全量移植

- 业务系统停机
- 数据库迁移、校验一致性
- 业务系统升级，接入新数据库

2. 全量+增量

- 先同步数据到最近某个时间戳
- 发布升级时停机维护
- 同步最后一段时间的变化数据
- 升级业务系统，接入新数据库

3. binlog+全量+增量

- 通过主库或者从库的 binlog 来解析和重新构造数据，实现复制

- 一般需要中间件等工具的支持：可以实现多线程，断点续传，全量历史和增量数据同步

- 实现自定义复杂异构数据结构

- 实现自动扩容和缩容，比如分库分表到单库单表，单库单表到分库分表，分4个库表

  到分64个库表

### 分布式事务

1. 为什么需要分布式事务
2. 分布式事务定义

分布式条件下，多个节点操作的整体事务一致性

3. 如何实现分布式事务的一致性

- 强一致性：XA
- 弱一致性
  - 不用事务，业务侧补偿冲正
  - 所谓的柔性事务，使用一套事务框架保证最终一致的事务

### XA分布式事务

1. 什么是XA：基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA分布式事务。 XA整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务
2. XA事务状态
3. 完整XA事务处理过程
4. 主流支持XA的框架：Atomikos和narayana
5. XA存在的问题

- 同步阻塞问题
- 单点故障
- 数据不一致

### BASE柔性事务

1. 定义
2. 常见模式

- TCC：通过手动补偿处理
- AT：通过自动补偿处理

### TCC/AT相关框架

1. TCC模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有服务业 务的Try状态来操作，如果都成功，则进行Confirm操作，如果任意一个Try发生错误，则全部Cancel。
2. TCC使用要求就是业务接口必须实现三段逻辑：

- try
- confirm
- cancel

3. TCC 不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务，不同于AT的是就是需要自行定义各个阶段的逻辑，对业务有侵入。
4. TCC注意的问题：

- 允许空回滚
- 防悬挂控制
- 幂等设计

5. SAGA：Saga模式没有try阶段，直接提交事务。复杂情况下，对回滚操作的设计要求较高。
6. AT：AT 模式就是两阶段提交，自动生成反向SQL
7. 柔性事务隔离级别：

- 事务特性：
  - 原子性：正常情况下保证
  - 一致性：在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一 致的。
  - 隔离性：在某个时间点，A事务能够读到B事务部分提交的结果。
  - 持久性：和本地事务一样，只要commit则数据被持久。
- 隔离级别：一般情况下都是读已提交（全局锁）、读未提交（无全局锁）。

8. Seata
9. mily
10. Shardingsphere

### 总结

本章要学习内容主要两大块：数据库的高可用，包括数据库的读写分离，分库分表，要学会读写分离、高可用、分库分表的原理，已经工程实现的方法，包括相关数据库框架、中间件的使用；另一大块是分布式事务，学会有多少种分布式事务，每种分布式事务的特点，使用的场景，优劣等等，会使用相关框架实现分布式事务。

## RPC和微服务

### RPC基本原理

1. RPC是什么
2. RPC的原理

- 设计
- 代理
- 序列化
- 网络传输
- 查找实现类

### RPC技术框架

1. 常见RPC技术
2. 设计一个RPC框架

### 从RPC到分布式服务化

1. 分布式业务场景，需要考虑的要点
2. 典型的分布式框架

### Dubbo技术原理

1. Dubbo介绍

- Dubbo功能

2. Dubbo技术原理

- 整体框架
- 框架应用

3. Dubbo应用场景
4. Dubbo最佳实践

### 微服务

1. 分布式微服务与SOA/ESB的区别
2. 配置/注册/元数据中心

- 配置中心
- 注册中心
- 元数据中心
- 如何实现XX中心

3. 服务的注册与发现
4. 服务的集群与路由
5. 服务的过滤与流控

### 微服务架构

1. 架构发展历程
2. 微服务发展历程

- 相应式微服务
- 服务网格与云原生
- 数据库网格
- 单元化架构

3. 微服务架构应用场景

- 微服务应用在复杂度低的情况下， 生产力反而比单体架构低
- 在复杂度高的地方，情况恰恰相反
- 随着复杂度升高，单体架构的生产 力快速下降，而微服务相对平稳

4. 微服务架构最佳实践

- 遗留系统改造

- 恰当粒度拆分

- 扩展立方体

- 自动化管理

- 分布式事务

- 完善监控体系

5. SpringCloud
6. 微服务相关框架工具

### 总结

本章从RPC的知识出发，到介绍微服务架构。重点要学习RPC框架的概念，并能动手实现一个简单的RPC框架。从RPC到分部化服务技术，了解软件架构发展的过程。学习Dubbo的技术原理、框架、设计思想等。学习微服务架构的基本概念、原理、微服务架构组成的模块、应用场景和微服务架构改造的关键点。学习SpringCloud一套微服务技术以及相关的框架工具，能够根据遇到的问题找到对应解决问题的方法和工具。

## 分布式缓存

### 缓存基础

1. 数据类型
2. 缓存加载时机

- 启动全量加载：全局有效，使用简单
- 懒加载
  - 同步使用加载：先看缓存是否有数据，没有的话从数据库读取；读取的数据，先放到内存，然后返回给调用方
  - 延迟异步加载：从缓存获取数据，不管是否为空直接返回：如果为空，则发起一个异步加载的线程，负责加载数据；异步线程负责维护缓存的数据，定期或根据条件触发更新

3. 缓存的有效性与数据同步

- 变动频率大、一致性要求高的数据，不大适合用缓存
- 有消息判断标准：
  - 读写比：对数据的写操作导致数据变动，意味着维护成本
  - 命中缓存意味着缓存数据被使用，意味着有价值
- 对数据一致性、性能、成本的综合衡量，引入缓存的指标

4. 缓存使用不当导致的问题

- 系统预热导致启动慢
- 系统内存资源耗尽

### 本地缓存

1. 简单本地缓存
2. Hibernate和Mybatis、Guava、Spring的Cache

### 远程缓存

1. Redis/memcachaed缓存中间件
2. Hazelcast/Ignite内存网格

### 缓存策略

1. 容量
2. 过期策略

- FIFO
- LRU

### 缓存常见问题

1. 缓存穿透

- 大量并发查询不存在的KEY，导致都直接将压力透传到数据库
- 解决
  - 缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY
  - Bloom过滤或RoaringBitmap 判断KEY是否存在
  - 完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新

2. 缓存击穿

- 某个KEY失效的时候，正好有大量并发请求访问这个KEY
- 解决
  - KEY的更新操作添加全局互斥锁
  - 完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新

3. 缓存雪崩

- 当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数 据库压力过大升值宕机
- 解决
  - 更新策略在时间上做到比较均匀
  - 使用的热数据尽量分散到不同的机器上
  - 多台机器做主从复制或者多副本，实现高可用
  - 实现熔断限流机制，对系统进行负载能力控制

### Reids

1. Redis基本功能
2. Redis六大使用场景

- 业务数据缓存
- 业务数据处理
- 全局一致计数
- 高效统计计数
- 发布订阅与Stream
- 分布式锁

3. Redis使用

- Java客户端
  - Jedis
  - Lettude
  - Redission
- Spring整合
- Mybatis整合

4. Redis高级功能

- Redis事务
- Redis管道技术
- 数据备份与恢复
- 性能优化
- 分区
- 使用经验

### Redis高可用

1. Redis主从复制：从单机到多节点
2. Redis Sentinel：走向高可用
3. Redis Cluster：分片

### Reddision

### Hazelcast

### 总结

本章学习缓存的相关知识。重点要理解缓存的概，包括缓存的加载机制、策略、使用场景和使用缓存的指标。要牢记缓存的常见问题(穿透、击穿、雪崩），并能在遇到问题时懂得使用学过的方法解决。Redis作为最常用的缓存中间件，重点学习期功能、原理、已经使用场景。能使用Redis客户端以及在其他框架的整合来使用。了解Redis怎样配置高可用，并结合数据库高可用的概念来学习。

## 分布式消息队列

### 系统间通信方式

1. 几种方式

- 文件：不方便、不及时
- Socket：使用麻烦
- 数据库：不实时
- RPC：调用关系复杂

2. MQ

### 从队列到服务

1. 消息队列的概念

- 消息
- 生产者
- 消费者

2. 消息队列的作用

- 异步通信
- 系统解耦
- 削峰平谷
- 可靠通信

### 消息模式与消息协议

1. 消息处理模式

- 点对点 - 对应于Queue
- 发布订阅 - 对应于Topic

2. 消息处理的保障

- 三种QoS
  - At Most once，至多一次，消息可能丢失但是不会重复发送
  - At Least Once，至少一次，消息不会丢失，但是可能会重复
  - Exactly once，精确一次，每条消息肯定会被传输一次且仅一次
- 消息处理的事务性：
  - 通过确认机制实现事务性
  - 可以被事务管理器管理，甚至可以支持XA

3. 消息的有序性：同一个Topic或Queue的消息，保障按顺序投递
4. 消息协议
5. JMS

6. 消息队列的通用结构
7. 开源消息中间件

- ActiveMQ/RabbitMQ
- Kafka/RocketMQ
- Apache Pulsar

### ActiveMQ

1. 简介
2. 主要功能

### Kafka

1. 什么是Kafka

Kafka 是一个消息系统，由 LinkedIn 于2011年设计开发，用作 LinkedIn 的活动流 （Activity Stream）和运营数据处理管道（Pipeline）的基础。

2. 基本概念

- Broker：Kafka 集群包含一个或多个服务器，这种服务器被称为 broker

- Topic：每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。 

  （物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或 多个 broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数 据存于何处）

- Partition：Partition 是物理上的概念，每个 Topic 包含一个或多个 Partition

- Producer

- Consumer

- Consumer Group

3. Kafka部署结构

- 单机
- 集群

4. Topic和Partition：多Partition支持水平扩展和并行处理，顺序写入提升吞吐性能
5. Partition和Replica：每个partition可以通过副本因子添加多个副本
6. Toptic特性：

- 通过partition增加可扩展性
- 通过顺序写入达到高吞吐
- 多副本增加容错性

### Kafka使用

### Kafka高级特性

1. 生产者

- 生产步骤
- 确认模式
- 同步发送
- 异步发送
- 顺序保证
- 消息可靠性传递

2. 消费者

- 消费者Group
- Offset同步提交
- Offset异步提交
- Offset自动提交
- Offset Seek

### 其他MQ产品

1. RabbitMQ
2. RocketMQ
3. Pulsar
4. EIP

### 动手写MQ

1. 内存MQ
2. 自定义Queue
3. 基于SpringMVC实现的MQServer
4. 功能完善的MQ
5. 体系完善的MQ

### 总结

本章学习了分布式消息队列。理解消息队列的核心概念和原理、功能，使用场景和几种消息协议，掌握消息队列的应用场景、处理模式。对于常用的开源消息中间件，如ActiveMQ、Kafka等，要懂得如何正确使用，了解各个消息中间件的特性，能够根据具体的业务应用场景选择适当的消息中间件。最后对自己提个更高的要求就能实现一个分布式消息队列。



























